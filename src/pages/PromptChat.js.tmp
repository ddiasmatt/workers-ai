import React, { useState, useEffect, useRef, useContext } from 'react';
import { useNavigate, useParams, useSearchParams } from 'react-router-dom';
import { ChatHistoryContext } from '../App';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import {
  Box,
  TextField,
  IconButton,
  Paper,
  Typography,
  Avatar,
  CircularProgress,
  List,
  ListItem,
  ListItemText,
  ListItemAvatar,
  Divider,
  Alert,
  Button,
  AppBar,
  Snackbar,
  Chip,
  Tooltip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  MenuItem,
  Card,
  CardContent,
  CardActions,
  Menu,
  ListItemIcon
} from '@mui/material';
import SendIcon from '@mui/icons-material/Send';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import PersonIcon from '@mui/icons-material/Person';
import SmartToyIcon from '@mui/icons-material/SmartToy';
import AttachFileIcon from '@mui/icons-material/AttachFile';
import PictureAsPdfIcon from '@mui/icons-material/PictureAsPdf';
import DescriptionIcon from '@mui/icons-material/Description';
import TableChartIcon from '@mui/icons-material/TableChart';
import WarningIcon from '@mui/icons-material/Warning';
import TuneIcon from '@mui/icons-material/Tune';
import SaveIcon from '@mui/icons-material/Save';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import AddIcon from '@mui/icons-material/Add';
import SettingsIcon from '@mui/icons-material/Settings';
import { 
  hasApiKey, 
  uploadFile,
  ConversationManager,
  sendMessageWithStreaming,
  retrieveFileContent
} from '../services/prompt';

// Modelos dispon√≠veis
const AVAILABLE_MODELS = [
  // GPT-4 Series
  { id: 'gpt-4.1', name: 'GPT-4.1 üî•', description: 'Nova gera√ß√£o com 1M+ tokens de contexto', contextWindow: 1047576, maxOutputTokens: 32768 },
  { id: 'gpt-4o', name: 'GPT-4o', description: '√öltima vers√£o GPT-4 otimizada', contextWindow: 128000, maxOutputTokens: 4096 },
  { id: 'gpt-4-turbo', name: 'GPT-4 Turbo', description: 'Vers√£o mais recente da s√©rie GPT-4', contextWindow: 128000, maxOutputTokens: 4096 },
  { id: 'gpt-4', name: 'GPT-4', description: 'Vers√£o est√°vel GPT-4', contextWindow: 8192, maxOutputTokens: 4096 },
  
  // Claude Series
  { id: 'claude-3-7-sonnet-20250219', name: 'Claude 3.7 Sonnet', description: 'Modelo Claude com alta capacidade', contextWindow: 200000, maxOutputTokens: 4096 },
  { id: 'claude-3-opus-20240229', name: 'Claude 3 Opus', description: 'Vers√£o premium do Claude com alta capacidade', contextWindow: 200000, maxOutputTokens: 4096 },
  
  // GPT-3.5 Series
  { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo', description: 'Vers√£o r√°pida e econ√¥mica', contextWindow: 16385, maxOutputTokens: 4096 }
];

// Ferramentas dispon√≠veis com as defini√ß√µes completas para a API
const AVAILABLE_TOOLS = [
  { 
    id: 'code_interpreter', 
    name: 'Interpretador de C√≥digo', 
    description: 'Executa c√≥digo Python para an√°lises e c√°lculos',
    type: 'code_interpreter',
    models: ['gpt-4o', 'gpt-4-turbo', 'gpt-4', 'gpt-3.5-turbo'],
    apiDefinition: {
      type: 'code_interpreter'
    }
  },
  { 
    id: 'retrieval', 
    name: 'Recupera√ß√£o de Conhecimento', 
    description: 'Pesquisa informa√ß√µes em arquivos anexados',
    type: 'retrieval',
    models: ['gpt-4o', 'gpt-4-turbo', 'gpt-4', 'gpt-3.5-turbo'],
    apiDefinition: {
      type: 'retrieval'
    }
  },
  { 
    id: 'web_browsing', 
    name: 'Navega√ß√£o Web', 
    description: 'Acessa e resume conte√∫do da web',
    type: 'web_browsing',
    models: ['gpt-4o', 'gpt-4-turbo', 'gpt-4', 'gpt-3.5-turbo'],
    apiDefinition: {
      type: 'web_browsing'
    }
  },
  { 
    id: 'web_search', 
    name: 'Pesquisa Web', 
    description: 'Pesquisa informa√ß√µes na internet em tempo real',
    type: 'function',
    models: ['gpt-4o', 'gpt-4-turbo', 'gpt-4', 'gpt-3.5-turbo', 'claude-3-7-sonnet-20250219', 'claude-3-opus-20240229'],
    apiDefinition: {
      type: 'function',
      function: {
        name: 'web_search',
        description: 'Pesquisa informa√ß√µes atualizadas na internet',
        parameters: {
          type: 'object',
          properties: {
            query: {
              type: 'string',
              description: 'A consulta de pesquisa'
            }
          },
          required: ['query']
        }
      }
    }
  },
  { 
    id: 'function_calling', 
    name: 'Chamada de Fun√ß√µes', 
    description: 'Estrutura dados para integra√ß√£o com APIs',
    type: 'function',
    models: ['gpt-4o', 'gpt-o3', 'gpt-4.5'],
    apiDefinition: {
      type: 'function',
      function: {
        name: 'get_data',
        description: 'Recupera dados de uma fonte externa',
        parameters: {
          type: 'object',
          properties: {
            query: {
              type: 'string',
              description: 'A consulta a ser executada'
            }
          },
          required: ['query']
        }
      }
    }
  },
  {
    id: 'vision',
    name: 'Vis√£o Computacional', 
    description: 'Processa e analisa imagens e v√≠deos',
    type: 'vision',
    models: ['gpt-4o', 'gpt-o3', 'gpt-4.5'],
    apiDefinition: {
      type: 'vision'
    }
  },
  {
    id: 'advanced_reasoning',
    name: 'Racioc√≠nio Avan√ßado', 
    description: 'Capacidades avan√ßadas para seguir instru√ß√µes espec√≠ficas',
    type: 'function',
    models: ['gpt-o3', 'gpt-4.5'],
    apiDefinition: {
      type: 'function',
      function: {
        name: 'advanced_reasoning',
        description: 'Aplicar racioc√≠nio avan√ßado para resolver problemas complexos',
        parameters: {
          type: 'object',
          properties: {
            problem: {
              type: 'string',
              description: 'O problema a ser resolvido'
            }
          },
          required: ['problem']
        }
      }
    }
  },
  {
    id: 'long_context',
    name: 'Contexto Longo', 
    description: 'Capacidade de lidar com 1M+ tokens de entrada',
    type: 'function',
    models: ['gpt-4.1'],
    apiDefinition: {
      type: 'function',
      function: {
        name: 'process_long_context',
        description: 'Processar e analisar documentos muito longos',
        parameters: {
          type: 'object',
          properties: {
            action: {
              type: 'string',
              description: 'A√ß√£o a ser executada no documento longo',
              enum: ['summarize', 'extract', 'analyze']
            }
          },
          required: ['action']
        }
      }
    }
  }
];

const PromptChat = () => {
  const { id } = useParams(); // ID usado para identificar a conversa no localStorage
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const { addToHistory } = useContext(ChatHistoryContext);
  
  // Estados para controle da interface
  const [input, setInput] = useState('');
  const [messages, setMessages] = useState([]);
  const [isTyping, setIsTyping] = useState(false);
  const [activeRunId, setActiveRunId] = useState(null);
  const [error, setError] = useState(null);
  const [snackbar, setSnackbar] = useState({ open: false, message: '' });
  const [uploadingFile, setUploadingFile] = useState(false);
  const [attachedFile, setAttachedFile] = useState(null);
  const [isResettingThread, setIsResettingThread] = useState(false);
  const [confirmResetOpen, setConfirmResetOpen] = useState(false);
  const [selectedModel, setSelectedModel] = useState('gpt-4.1');
  const [settingsOpen, setSettingsOpen] = useState(false);
  const [savePresetOpen, setPresetSaveOpen] = useState(false);
  const [presetName, setPresetName] = useState('');
  const [presets, setPresets] = useState([]);
  const [temperature, setTemperature] = useState(0.7);
  const [maxTokens, setMaxTokens] = useState(2048);
  const [systemPrompt, setSystemPrompt] = useState(() => {
    // Tentar carregar o system prompt salvo do localStorage
    const savedPrompt = localStorage.getItem('default_system_prompt');
    return savedPrompt || 'You are a helpful assistant. When asked about your version, make it clear which model you are running on. Answer questions clearly and concisely.';
  });
  const [selectedTools, setSelectedTools] = useState([]);
  
  // Estados para gerenciamento de presets
  const [presetManagerOpen, setPresetManagerOpen] = useState(false);
  const [presetToEdit, setPresetToEdit] = useState(null);
  const [presetToDelete, setPresetToDelete] = useState(null);
  const [confirmDeleteOpen, setConfirmDeleteOpen] = useState(false);
  const [presetAnchorEl, setPresetAnchorEl] = useState(null);
  const [currentPreset, setCurrentPreset] = useState(null);
  const [presetAttachedFiles, setPresetAttachedFiles] = useState([]);
  const [uploadingPresetFile, setUploadingPresetFile] = useState(false);
  
  // Refer√™ncias
  const fileInputRef = useRef(null);
  const presetFileInputRef = useRef(null);
  const messagesEndRef = useRef(null);
  const conversationRef = useRef(new ConversationManager(systemPrompt));
  
  // Carregar presets salvos
  useEffect(() => {
    try {
      const savedPresets = localStorage.getItem('chat_presets');
      if (savedPresets) {
        setPresets(JSON.parse(savedPresets));
      }
    } catch (e) {
      console.error('Error loading presets:', e);
    }
  }, []);
  
  // Verificar se deve abrir diretamente as configura√ß√µes ou di√°logo de salvar worker
  useEffect(() => {
    const shouldOpenSettings = searchParams.get('openSettings') === 'true';
    const shouldCreateWorker = searchParams.get('createWorker') === 'true';
    
    if (shouldOpenSettings || shouldCreateWorker) {
      // Usar setTimeout para garantir que o preset tenha sido carregado
      setTimeout(() => {
        // Abrir as configura√ß√µes
        setSettingsOpen(true);
        
        // Se for para criar um worker, abrir tamb√©m o di√°logo de salvar preset ap√≥s um tempo
        if (shouldCreateWorker) {
          setTimeout(() => {
            handleOpenSavePreset();
          }, 500);
        }
      }, 300);
      
      // Limpar o par√¢metro da URL para n√£o reabrir as configura√ß√µes ao recarregar
      const newUrl = window.location.pathname;
      navigate(newUrl, { replace: true });
    }
  }, [searchParams, navigate]);
  
  // Obter ChatHistory do contexto
  const { chatHistory } = useContext(ChatHistoryContext);

  // Inicializar ou carregar conversa
  useEffect(() => {
    console.log('Iniciando carregamento de conversa, ID:', id);
    const conversation = conversationRef.current;
    
    // Limpar mensagens para evitar flash de conte√∫do antigo
    setMessages([]);
    
    // Verificar se o ID √© um preset ou uma conversa vinculada a um preset
    if (id) {
      // Tenta carregar configura√ß√µes do preset
      try {
        const preset = presets.find(p => p.id === id);
        if (preset) {
          console.log('Carregando worker:', preset.name);
          
          // Atualizar o preset atual
          setCurrentPreset(preset);
          
          // Aplicar configura√ß√µes do preset
          setSelectedModel('gpt-4.1'); // Usar sempre GPT-4.1 como modelo padr√£o
          setSystemPrompt(preset.systemPrompt || '');
          setTemperature(preset.temperature || 0.7);
          
          // Ajustar tokens m√°ximos considerando o limite do modelo
          const modelMax = AVAILABLE_MODELS.find(m => m.id === preset.model)?.maxOutputTokens || 4096;
          setMaxTokens(Math.min(preset.maxTokens || 2048, modelMax));
          
          setSelectedTools(preset.tools || []);
          
          // Carregar arquivos anexados se existirem
          setPresetAttachedFiles(preset.attachedFiles || []);
          
          // Verificar se estamos criando uma nova conversa
          const searchParams = new URLSearchParams(window.location.search);
          const isNewChat = searchParams.get('new') === 'true';
          const forceNewChat = searchParams.get('forcenew') === 'true';
          
          // Se √© uma solicita√ß√£o para nova conversa
          if (isNewChat) {
            // Se n√£o estiver for√ßando nova conversa, verificar se j√° existe uma conversa ativa com este worker
            if (!forceNewChat) {
              const existingChats = chatHistory.filter(chat => 
                chat.workerId === preset.id && 
                chat.messageCount > 0 // Verificar se possui mensagens
              );
              
              if (existingChats.length > 0) {
                // Ordenar por data de √∫ltima atividade (mais recente primeiro)
                existingChats.sort((a, b) => new Date(b.lastActivity) - new Date(a.lastActivity));
                
                // Redirecionar para a conversa existente mais recente
                const latestChat = existingChats[0];
                console.log('Conversa existente encontrada, redirecionando para:', latestChat.id);
                
                // Atualizar a URL sem recarregar a p√°gina
                window.history.replaceState(null, '', `/prompt-chat/${latestChat.id}`);
                
                // Carregar a conversa existente
                const loaded = conversation.load(latestChat.id);
                if (loaded) {
                  console.log('Conversa carregada com sucesso');
                  loadConversationToUI(conversation);
                  
                  setSnackbar({
                    open: true,
                    message: `Usando conversa existente com o worker "${preset.name}"`
                  });
                  
                  return; // Importante: sair do fluxo de carregamento
                }
              }
            }
            
            // Se n√£o existe uma conversa ou se n√£o conseguiu carregar, criar uma nova
            const newChatId = `${preset.id}_chat_${Date.now()}`;
            
            // Atualizar a URL sem recarregar a p√°gina
            window.history.replaceState(null, '', `/prompt-chat/${newChatId}`);
            
            // Iniciar nova conversa com o system prompt do worker
            conversation.reset(preset.systemPrompt || '');
            console.log('Iniciando nova conversa com ID:', newChatId);
            
            // Usar sempre o modelo GPT-4.1
            const modelInfo = AVAILABLE_MODELS[0]; // Apenas GPT-4.1 est√° dispon√≠vel
            
            // Notificar o usu√°rio sobre o modelo que ser√° usado
            setSnackbar({
              open: true,
              message: `Usando ${modelInfo.name} (${modelInfo.id}) para esta conversa`
            });
            
            // Processar arquivos anexados ao worker, se existirem
            if (preset.attachedFiles && preset.attachedFiles.length > 0) {
              console.log(`Worker tem ${preset.attachedFiles.length} arquivos anexados, processando...`);
              
              // Adicionar mensagem ao sistema informando sobre os arquivos
              const filesList = preset.attachedFiles.map(file => file.name).join(", ");
              const filesMessage = `O worker "${preset.name}" tem os seguintes arquivos anexados para refer√™ncia: ${filesList}`;
              conversation.addMessage('system', filesMessage);
              
              // Para cada arquivo anexado, tentar recuperar conte√∫do e adicionar ao contexto
              preset.attachedFiles.forEach(async (file) => {
                try {
                  if (file.id) {
                    const fileContent = await retrieveFileContent(file.id);
                    const fileContextMsg = `Conte√∫do do arquivo anexado "${file.name}":\n${JSON.stringify(fileContent.content)}`;
                    conversation.addMessage('system', fileContextMsg);
                    
                    // Salvar a conversa com o contexto dos arquivos
                    conversation.save(newChatId);
                    console.log(`Arquivo ${file.name} processado e adicionado ao contexto`);
                  }
                } catch (err) {
                  console.error(`Erro ao processar arquivo ${file.name}:`, err);
                }
              });
            }
            
            // Adicionar ao hist√≥rico imediatamente para atualizar a barra lateral
            addToHistory({
              id: newChatId,
              title: 'Nova conversa com ' + preset.name,
              messageCount: 0,
              modelInfo: 'gpt-4.1', // Sempre usar GPT-4.1
              isPreset: true,
              workerId: preset.id
            });
            
          // Se n√£o √© uma nova conversa, verificar se √© uma conversa existente
          } else if (localStorage.getItem(`conversation_${id}`)) {
            console.log('Tentando carregar conversa existente:', id);
            const loaded = conversation.load(id);
            if (loaded) {
              console.log('Conversa carregada com sucesso');
              loadConversationToUI(conversation);
              
              // Verificar se os arquivos anexados j√° foram adicionados ao contexto
              const hasAttachedFilesContext = conversation.getHistory().some(msg => 
                msg.role === 'system' && msg.content.includes('arquivos anexados para refer√™ncia')
              );
              
              // Adicionar informa√ß√£o sobre arquivos anexados ao worker se necess√°rio
              if (!hasAttachedFilesContext && preset.attachedFiles && preset.attachedFiles.length > 0) {
                console.log(`Adicionando informa√ß√µes sobre ${preset.attachedFiles.length} arquivos anexados √† conversa existente`);
                
                // Adicionar mensagem ao sistema informando sobre os arquivos
                const filesList = preset.attachedFiles.map(file => file.name).join(", ");
                const filesMessage = `O worker "${preset.name}" tem os seguintes arquivos anexados para refer√™ncia: ${filesList}`;
                conversation.addMessage('system', filesMessage);
                
                // Salvar a conversa com a informa√ß√£o atualizada
                conversation.save(id);
              }
            } else {
              console.warn('Falha ao carregar conversa, iniciando nova');
              conversation.reset(preset.systemPrompt || '');
            }
          // Caso n√£o seja nem nova nem existente (primeira vez acessando este worker)
          } else {
            console.log('Nenhuma conversa existente, criando primeira conversa com ID:', id);
            conversation.reset(preset.systemPrompt || '');
          }
        } else {
          console.log('ID n√£o corresponde a nenhum preset, tentando carregar como conversa normal:', id);
          setCurrentPreset(null);
          
          // Tentar carregar como conversa normal
          const loaded = conversation.load(id);
          if (loaded) {
            console.log('Conversa normal carregada com sucesso');
            loadConversationToUI(conversation);
          } else {
            console.warn('Falha ao carregar conversa normal, iniciando nova conversa');
            conversation.reset(systemPrompt);
          }
        }
      } catch (e) {
        console.error('Error loading preset or conversation:', e);
        setCurrentPreset(null);
        conversation.reset(systemPrompt);
      }
    } else {
      // Se n√£o temos um ID v√°lido, redirecionar para a p√°gina inicial
      console.log('ID de conversa inv√°lido, redirecionando para a p√°gina inicial');
      navigate('/');
    }
  }, [id, presets, chatHistory]);
  
  // Estado para controlar quando o system prompt foi alterado manualmente
  const [manualSystemPromptChange, setManualSystemPromptChange] = useState(false);
  
  // Efeito separado para atualizar o system prompt quando ele √© alterado manualmente
  useEffect(() => {
    // S√≥ reinicia a conversa se houve altera√ß√£o manual e j√° existem mensagens
    if (manualSystemPromptChange && messages.length > 0) {
      console.log('Reiniciando conversa com novo system prompt (altera√ß√£o manual)');
      const conversation = conversationRef.current;
      conversation.reset(systemPrompt);
      setMessages([]);
      
      setSnackbar({
        open: true,
        message: 'Conversa reiniciada com o novo system prompt'
      });
      
      // Resetar flag ap√≥s processar
      setManualSystemPromptChange(false);
    }
  }, [manualSystemPromptChange, messages.length, systemPrompt]);
  
  // N√£o precisamos mais desativar ferramentas para GPT-4.1
  // Todas as ferramentas est√£o dispon√≠veis para todos os modelos agora
  
  // Fun√ß√£o auxiliar para carregar conversa para a UI
  const loadConversationToUI = (conversation) => {
    // Converter o hist√≥rico para o formato de mensagens da UI
    const uiMessages = conversation.getHistory().map(msg => ({
      role: msg.role,
      content: msg.content,
      // Usar o timestamp original ou criar um novo se n√£o existir
      timestamp: msg.timestamp || new Date().toISOString(),
      // Preservar arquivo anexado se existir
      ...(msg.attachedFile ? { attachedFile: msg.attachedFile } : {})
    }));
    
    // Debug para verifica√ß√£o
    console.log('Carregando mensagens com timestamps:', uiMessages);
    
    // Filtrar mensagens de sistema que n√£o queremos mostrar na UI
    const visibleMessages = uiMessages.filter(msg => msg.role !== 'system');
    setMessages(visibleMessages);
    
    // Recuperar o system prompt se existir e n√£o estivermos usando um preset
    if (!currentPreset) {
      const systemMessage = conversation.getHistory().find(msg => msg.role === 'system');
      if (systemMessage) {
        setSystemPrompt(systemMessage.content);
      }
    }
  };
  
  // Estado para controlar se deve rolar automaticamente
  const [shouldScrollToBottom, setShouldScrollToBottom] = useState(true);
  const [isUserScrolling, setIsUserScrolling] = useState(false);
  
  // Detectar quando o usu√°rio est√° rolando manualmente
  const handleScroll = (e) => {
    const { scrollTop, scrollHeight, clientHeight } = e.currentTarget;
    const isAtBottom = scrollHeight - scrollTop - clientHeight < 100;
    
    // Se o usu√°rio estiver rolando manualmente (n√£o causado pelo auto-scroll)
    if (!isUserScrolling) {
      setIsUserScrolling(true);
      setShouldScrollToBottom(isAtBottom);
      
      // Resetar ap√≥s 1 segundo sem rolagem
      setTimeout(() => {
        setIsUserScrolling(false);
      }, 1000);
    }
  };
  
  // Rolar para a √∫ltima mensagem apenas quando necess√°rio
  useEffect(() => {
    // S√≥ rolar automaticamente se o usu√°rio estiver no final da conversa ou se for uma nova mensagem
    if (shouldScrollToBottom && !isUserScrolling) {
      messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages, shouldScrollToBottom]);
  
  // Enviar mensagem
  const handleSendMessage = async (e) => {
    e.preventDefault();
    if ((!input.trim() && !attachedFile) || isTyping || activeRunId) return;
    
    if (!hasApiKey()) {
      setSnackbar({
        open: true,
        message: 'Por favor, configure sua chave de API da OpenAI primeiro.'
      });
      return;
    }
    
    const userContent = input.trim();
    setInput('');
    
    // Construir a mensagem do usu√°rio para a UI
    const userMessage = {
      role: 'user',
      content: userContent,
      timestamp: new Date().toISOString(),
      ...(attachedFile ? { attachedFile } : {})
    };
    
    // Limpar arquivo anexado
    const fileToProcess = attachedFile;
    setAttachedFile(null);
    
    // Adicionar mensagem do usu√°rio √† UI e uma mensagem tempor√°ria do assistente
    setMessages(prev => [
      ...prev, 
      userMessage,
      {
        role: 'assistant',
        content: 'Pensando...',
        timestamp: new Date().toISOString(),
        isStreaming: true,
        isThinking: true
      }
    ]);
    
    setIsTyping(true);
    setError(null);
    
    // Vari√°vel para armazenar conte√∫do final do usu√°rio
    let finalUserContent = userContent;
      
    // Processar arquivo anexado se existir  
    if (fileToProcess) {
      try {
        // Adicionar informa√ß√µes sobre o arquivo na mensagem para a UI
        finalUserContent = userContent ? 
          `${userContent}\n\n[Arquivo anexado: ${fileToProcess.name}]` : 
          `[Arquivo anexado: ${fileToProcess.name}]`;
        
        // Se temos um ID de arquivo, tentar recuperar seu conte√∫do
        if (fileToProcess.id) {
          try {
            const fileContent = await retrieveFileContent(fileToProcess.id);
            
            // Adicionar conte√∫do do arquivo como contexto
            const fileContextMsg = `File content:\n${JSON.stringify(fileContent.content)}`;
            
            // Adicionar ao hist√≥rico, mas n√£o mostrar na UI
            conversationRef.current.addMessage('user', fileContextMsg);
          } catch (fileErr) {
            console.warn('Could not retrieve file content, continuing with standard message', fileErr);
          }
        }
      } catch (fileErr) {
        console.error('Error processing file:', fileErr);
      }
    }
    
    // Verificar se estamos usando um worker com arquivos anexados
    const currentChatId = window.location.pathname.split('/').pop();
    const isWorkerChat = currentChatId.includes('_chat_');
    
    if (isWorkerChat && !fileToProcess) {
      const workerId = currentChatId.split('_chat_')[0];
      const currentWorker = presets.find(p => p.id === workerId);
      
      // Se o worker tem arquivos anexados, mencion√°-los em cada mensagem do usu√°rio
      if (currentWorker?.attachedFiles && currentWorker.attachedFiles.length > 0) {
        const fileNames = currentWorker.attachedFiles.map(f => f.name).join(", ");
          
        // Checar se √© a primeira mensagem do usu√°rio
        const isFirstMessage = messages.filter(m => m.role === 'user').length === 0;
        
        // Checar se o conte√∫do do arquivo j√° est√° no hist√≥rico
        const hasFileContent = conversationRef.current.getHistory().some(msg => 
          msg.content && msg.content.includes('Conte√∫do recuperado do arquivo anexado')
        );
        
        // Se for a primeira mensagem e o conte√∫do ainda n√£o estiver no hist√≥rico, buscamos os arquivos
        if (isFirstMessage && !hasFileContent) {
          // Buscar conte√∫do dos arquivos anexados
          setSnackbar({
            open: true,
            message: 'Carregando conte√∫do dos arquivos anexados...'
          });
          
          // Para cada arquivo anexado, tentar recuperar conte√∫do e adicionar ao contexto
          const filePromises = currentWorker.attachedFiles.map(async (file) => {
            try {
              if (file.id) {
                const fileContent = await retrieveFileContent(file.id);
                const content = typeof fileContent.content === 'string' 
                  ? fileContent.content.substring(0, 500) + (fileContent.content.length > 500 ? '...' : '')
                  : JSON.stringify(fileContent.content).substring(0, 500) + '...';
                
                const fileContextMsg = `Conte√∫do recuperado do arquivo anexado "${file.name}":\n${content}`;
                conversationRef.current.addMessage('system', fileContextMsg);
                return file.name;
              }
            } catch (err) {
              console.error(`Erro ao processar arquivo ${file.name}:`, err);
              return null;
            }
          });
          
          // Esperar que todos os arquivos sejam processados
          Promise.all(filePromises).then(results => {
            const loadedFiles = results.filter(Boolean);
            if (loadedFiles.length > 0) {
              console.log(`Conte√∫do carregado de ${loadedFiles.length} arquivos`);
              // Salvar a conversa com o conte√∫do dos arquivos
              conversationRef.current.save(currentChatId);
              
              setSnackbar({
                open: true,
                message: `Conte√∫do de ${loadedFiles.length} arquivos carregado com sucesso`
              });
            }
          });
        }
        
        if (isFirstMessage) {
          // Na primeira mensagem, damos mais contexto
          finalUserContent += `\n\nOs seguintes arquivos foram anexados a este worker e est√£o dispon√≠veis para sua consulta: ${fileNames}.\nUtilize as informa√ß√µes contidas nestes arquivos para responder √†s minhas perguntas, quando relevante.`;
        } else {
          // Nas mensagens subsequentes, apenas lembramos da exist√™ncia dos arquivos
          finalUserContent += `\n\nLembre-se que voc√™ tem acesso aos seguintes arquivos para refer√™ncia: ${fileNames}`;
      }
    }
    
    // Iniciar streaming da resposta
    let currentAssistantMessage = '';
    
    try {
      // Preparar op√ß√µes adicionais com base nas ferramentas selecionadas
      const apiOptions = {
        temperature: temperature,
        max_tokens: maxTokens,
        attachedFile: fileToProcess  // Passar o arquivo anexado para a API
      };
      
      // Adicionar ferramentas se houver alguma selecionada (todos os modelos atuais suportam)
      if (selectedTools.length > 0) {
        try {
          // Usar as defini√ß√µes de API pr√©-configuradas para cada ferramenta
          const tools = selectedTools.map(toolId => {
            const tool = AVAILABLE_TOOLS.find(t => t.id === toolId);
            if (tool && tool.apiDefinition) {
              return { ...tool.apiDefinition };
            }
            return null;
          }).filter(Boolean); // Remover itens nulos
          
          if (tools.length > 0) {
            apiOptions.tools = tools;
            apiOptions.tool_choice = "auto";
            console.log('Sending tools:', JSON.stringify(tools, null, 2)); // Debug formatado
          }
        } catch (toolError) {
          console.error('Error preparing tools:', toolError);
        }
      }
      
      console.log(`Enviando mensagem usando modelo: ${selectedModel}`);
      // Garantir que estamos usando Claude 3.7 se nenhum modelo estiver definido
      const modelToUse = selectedModel || 'claude-3-7-sonnet-20250219';
      
      try {
        const streamController = await sendMessageWithStreaming(
          conversationRef.current,
          finalUserContent,
          modelToUse,
          {
            onData: (data) => {
              // Atualizar o texto conforme √© recebido
              currentAssistantMessage = data.content || '';
              const deltaText = data.delta || '';
              
              // Atualizar a mensagem na interface em tempo real
              setMessages(prev => {
                const messageIndex = prev.findIndex(msg => 
                  msg.role === 'assistant' && (msg.isThinking || msg.isStreaming)
                );
                
                if (messageIndex !== -1) {
                  const updatedMessages = [...prev];
                  updatedMessages[messageIndex] = {
                    ...updatedMessages[messageIndex],
                    content: currentAssistantMessage,
                    lastDelta: deltaText,
                    isThinking: false,
                    isStreaming: true,
                    timestamp: new Date().toISOString()
                  };
                  return updatedMessages;
                }
                
                return prev;
              });
            },
            onComplete: (result) => {
              // Finalizar a mensagem quando o streaming terminar
              setMessages(prev => {
                const assistantMessageIndex = prev.findIndex(
                  msg => msg.role === 'assistant' && msg.isStreaming
                );
                
                if (assistantMessageIndex > -1) {
                  const updatedMessages = [...prev];
                  updatedMessages[assistantMessageIndex] = {
                    ...updatedMessages[assistantMessageIndex],
                    content: result.content || currentAssistantMessage,
                    isStreaming: false,
                    isThinking: false
                  };
                  return updatedMessages;
                }
                
                return prev;
              });
              
              // Salvar conversa atualizada - usar o ID da URL atual
              const currentChatId = window.location.pathname.split('/').pop();
              conversationRef.current.save(currentChatId);
              
              // Atualizar o t√≠tulo na lista de conversas recentes ap√≥s a primeira mensagem
              if (messages.length <= 2) { // Primeira intera√ß√£o (usu√°rio + assistente)
                const messageText = messages[0]?.content || input;
                const title = messageText.substring(0, 30) + (messageText.length > 30 ? '...' : '');
                // Atualizar o hist√≥rico com o t√≠tulo da conversa baseado na primeira mensagem
                addToHistory({
                  id: currentChatId,
                  title: title,
                  messageCount: 2, // Usu√°rio + assistente
                  lastActivity: new Date()
                });
              }
              
              // Limpar status
              setActiveRunId(null);
              setIsTyping(false);
            },
            onError: (errorMsg) => {
              console.error('Streaming error:', errorMsg);
              
              // Formatar mensagem de erro para ser mais √∫til
              let errorMessage = 'Desculpe, ocorreu um erro durante o processamento da resposta.';
              
              // Erros espec√≠ficos de ferramenta
              if (errorMsg.includes('Missing required parameter: \'tools[0].function\'')) {
                errorMessage = 'Erro de configura√ß√£o de ferramentas: Esta ferramenta requer par√¢metros adicionais. Por favor, desative as ferramentas nas configura√ß√µes ou selecione outro modelo.';
              } else if (errorMsg.includes('tool_choice')) {
                errorMessage = 'Erro de configura√ß√£o: Problema com a sele√ß√£o de ferramentas. Por favor, desative as ferramentas nas configura√ß√µes.';
              } else if (errorMsg.toLowerCase().includes('model')) {
                errorMessage = 'Erro de modelo: O modelo selecionado pode n√£o estar dispon√≠vel ou n√£o suportar as ferramentas selecionadas.';
              } else if (errorMsg.toLowerCase().includes('error')) {
                // Manter a mensagem de erro original se parece √∫til
                errorMessage = 'Erro: ' + errorMsg;
              }
              
              setError('Erro: ' + errorMessage);
              setIsTyping(false);
              setActiveRunId(null);
              
              // Exibir aviso vis√≠vel para o usu√°rio
              setSnackbar({
                open: true,
                message: 'Erro: Tente desativar as ferramentas nas configura√ß√µes'
              });
              
              // Atualizar a mensagem "Pensando..." para mostrar o erro
              setMessages(prev => {
                const messageIndex = prev.findIndex(msg => 
                  msg.role === 'assistant' && (msg.isThinking || msg.isStreaming)
                );
                
                if (messageIndex !== -1) {
                  const updatedMessages = [...prev];
                  updatedMessages[messageIndex] = {
                    ...updatedMessages[messageIndex],
                    content: errorMessage,
                    isThinking: false,
                    isStreaming: false,
                    isError: true
                  };
                  return updatedMessages;
                }
                
                return prev;
              });
            }
          },
          apiOptions
        );
        
        // Armazenar refer√™ncia ao controller para cancelamento
        setActiveRunId(streamController);
      } catch (streamError) {
        console.error('Error starting streaming:', streamError);
        setError('Erro ao iniciar streaming: ' + (streamError.message || 'Erro desconhecido'));
        setIsTyping(false);
        setActiveRunId(null);
        throw streamError;
      }
      
    } catch (err) {
      console.error('Error sending message:', err);
      
      // Formatar mensagem de erro para ser mais √∫til
      let errorMessage = 'Desculpe, ocorreu um erro ao processar sua mensagem.';
      
      // Erros espec√≠ficos
      if (err.message && err.message.includes('Missing required parameter: \'tools[0].function\'')) {
        errorMessage = 'Erro de configura√ß√£o de ferramentas: Esta ferramenta requer par√¢metros adicionais. Por favor, desative as ferramentas nas configura√ß√µes.';
        
        // Remover automaticamente ferramentas problem√°ticas
        setSelectedTools([]);
        
        // Notificar o usu√°rio
        setSnackbar({
          open: true,
          message: 'Ferramentas desativadas automaticamente devido a erros de compatibilidade'
        });
      } else if (err.message && err.message.includes('not available')) {
        errorMessage = 'O modelo selecionado n√£o est√° dispon√≠vel. Por favor, selecione outro modelo nas configura√ß√µes.';
      } else if (err.message) {
        errorMessage = 'Erro: ' + err.message;
      }
      
      setError('Erro: ' + errorMessage);
      setIsTyping(false);
      
      // Substituir a mensagem "Pensando..." por uma mensagem de erro
      setMessages(prev => {
        const thinkingIndex = prev.findIndex(
          msg => msg.role === 'assistant' && msg.isThinking
        );
        
        if (thinkingIndex > -1) {
          const newMessages = [...prev];
          newMessages[thinkingIndex] = {
            role: 'assistant',
            content: errorMessage,
            timestamp: new Date().toISOString(),
            isError: true,
            isStreaming: false,
            isThinking: false
          };
          return newMessages;
        }
        
        return prev;
      });
    }
  };
  
  // Abrir o seletor de arquivo para mensagem
  const handleOpenFileSelector = () => {
    fileInputRef.current?.click();
  };

  // Abrir o seletor de arquivo para preset
  const handleOpenPresetFileSelector = () => {
    presetFileInputRef.current?.click();
  };
  
  // Processar os arquivos selecionados para mensagem
  const handleFileSelected = async (e) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;
    
    // Verificar se j√° existe algum arquivo anexado
    if (attachedFile) {
      setSnackbar({
        open: true,
        message: 'Remova o arquivo atual antes de anexar novos arquivos'
      });
      return;
    }
    
    setUploadingFile(true);
    setSnackbar({
      open: true,
      message: `Enviando ${files.length} arquivo(s)...`
    });
    
    // Apenas processamos o primeiro arquivo para a interface de chat
    const file = files[0];
    
    // Verificar o tipo de arquivo (permitir apenas PDF, CSV, TXT, Markdown)
    const allowedTypes = ['application/pdf', 'text/csv', 'text/plain', 'text/markdown'];
    const fileExtension = file.name.split('.').pop()?.toLowerCase();
    
    if (!allowedTypes.includes(file.type) && 
        !['pdf', 'csv', 'txt', 'md', 'markdown'].includes(fileExtension)) {
      setSnackbar({
        open: true,
        message: 'Somente arquivos PDF, CSV, TXT e Markdown s√£o suportados'
      });
      setUploadingFile(false);
      return;
    }
    
    try {
      // Se houver mais de um arquivo, avise o usu√°rio que apenas o primeiro ser√° usado
      if (files.length > 1) {
        setSnackbar({
          open: true,
          message: 'Apenas o primeiro arquivo ser√° usado na mensagem.'
        });
      }
      
      const response = await uploadFile(file);
      setAttachedFile({
        id: response.id,
        name: file.name,
        type: file.type,
        extension: fileExtension
      });
      
      setTimeout(() => {
        setSnackbar({
          open: true,
          message: 'Arquivo anexado com sucesso: ' + file.name
        });
      }, 1000);
    } catch (err) {
      console.error('Error uploading file:', err);
      setSnackbar({
        open: true,
        message: 'Erro ao enviar arquivo: ' + (err.message || 'Erro desconhecido')
      });
    } finally {
      setUploadingFile(false);
      // Limpar o input para permitir selecionar o mesmo arquivo novamente
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };
  
  // Remover o arquivo anexado da mensagem
  const handleRemoveFile = () => {
    setAttachedFile(null);
    setSnackbar({
      open: true,
      message: 'Arquivo removido'
    });
  };
  
  // Processar arquivos selecionados para preset
  const handlePresetFileSelected = async (e) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;
    
    setUploadingPresetFile(true);
    setSnackbar({
      open: true,
      message: `Enviando ${files.length} arquivo(s) para o modelo...`
    });
    
    // Permitimos m√∫ltiplos arquivos para presets
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      
      // Verificar o tipo de arquivo (permitir apenas PDF, CSV, TXT, Markdown)
      const allowedTypes = ['application/pdf', 'text/csv', 'text/plain', 'text/markdown'];
      const fileExtension = file.name.split('.').pop()?.toLowerCase();
      
      if (!allowedTypes.includes(file.type) && 
          !['pdf', 'csv', 'txt', 'md', 'markdown'].includes(fileExtension)) {
        setSnackbar({
          open: true,
          message: `Arquivo ${file.name} ignorado: somente PDF, CSV, TXT e Markdown s√£o suportados`
        });
        continue;
      }
      
      try {
        const response = await uploadFile(file);
        setPresetAttachedFiles(prev => [
          ...prev, 
          {
            id: response.id,
            name: file.name,
            type: file.type,
            extension: fileExtension,
            size: file.size,
            uploadedAt: new Date().toISOString()
          }
        ]);
      } catch (err) {
        console.error(`Error uploading file ${file.name}:`, err);
        setSnackbar({
          open: true,
          message: `Erro ao enviar arquivo ${file.name}: ${err.message || 'Erro desconhecido'}`
        });
      }
    }
    
    setUploadingPresetFile(false);
    // Limpar o input para permitir selecionar o mesmo arquivo novamente
    if (presetFileInputRef.current) {
      presetFileInputRef.current.value = '';
    }
    
    setSnackbar({
      open: true,
      message: 'Arquivos adicionados ao modelo'
    });
  };
  
  // Remover arquivo do preset
  const handleRemovePresetFile = (fileId) => {
    setPresetAttachedFiles(prev => prev.filter(file => file.id !== fileId));
    setSnackbar({
      open: true,
      message: 'Arquivo removido do modelo'
    });
  };
  
  // Abrir di√°logo de configura√ß√µes
  const handleOpenSettings = () => {
    setSettingsOpen(true);
  };
  
  // Salvar configura√ß√µes
  const handleSaveSettings = () => {
    // Obter a conversa atual
    const conversation = conversationRef.current;
    const currentSystemPrompt = conversation.getHistory().find(msg => msg.role === 'system')?.content;
    
    // Verificar se alguma configura√ß√£o importante mudou
    const needsReset = currentSystemPrompt !== systemPrompt;
    
    // Atualizar todas as configura√ß√µes no estado atual
    if (needsReset) {
      // Se o system prompt mudou, precisamos reiniciar a conversa
      setManualSystemPromptChange(true);
      conversation.reset(systemPrompt);
      setMessages([]);
      
      setSnackbar({
        open: true,
        message: 'Configura√ß√µes atualizadas e conversa reiniciada'
      });
    } else {
      // Outras configura√ß√µes que n√£o exigem reinicializa√ß√£o da conversa
      setSnackbar({
        open: true,
        message: 'Configura√ß√µes atualizadas'
      });
    }
    
    // Fechar o di√°logo de configura√ß√µes
    setSettingsOpen(false);
    
    // Salvar a conversa atual com configura√ß√µes atualizadas
    const currentChatId = window.location.pathname.split('/').pop();
    conversation.save(currentChatId);
    
    // Salvar system prompt separadamente para garantir que seja carregado corretamente
    localStorage.setItem('default_system_prompt', systemPrompt);
  };
  
  // Abrir di√°logo para salvar preset
  const handleOpenSavePreset = () => {
    setPresetName('');
    // Limpar arquivos anexados se n√£o estamos editando um preset
    if (!presetToEdit) {
      setPresetAttachedFiles([]);
    }
    setPresetSaveOpen(true);
  };
  
  // Salvar preset atual
  const handleSavePreset = () => {
    if (!presetName.trim()) {
      setSnackbar({
        open: true,
        message: 'Por favor, informe um nome para o preset'
      });
      return;
    }
    
    try {
      let updatedPresets;
      let presetId;
      let isEditing = false;
      
      // Verificar se estamos editando um preset existente
      if (presetToEdit) {
        // Estamos editando um preset existente
        presetId = presetToEdit.id;
        isEditing = true;
        
        // Atualizar o preset existente
        updatedPresets = presets.map(p => {
          if (p.id === presetId) {
            // Manter dados que n√£o devem ser alterados
            const hasConversation = p.hasConversation;
            const lastUpdated = new Date().toISOString();
            const createdAt = p.createdAt;
            
            return {
              ...p,
              name: presetName.trim(),
              model: selectedModel,
              systemPrompt: systemPrompt,
              temperature: temperature,
              maxTokens: maxTokens,
              tools: selectedTools,
              lastUpdated,
              // Preservar status da conversa
              hasConversation,
              // Atualizar arquivos anexados
              attachedFiles: presetAttachedFiles
            };
          }
          return p;
        });
      } else {
        // Criando um novo preset
        presetId = `preset_${Date.now()}`;
        
        // Criar objeto do preset
        const newPreset = {
          id: presetId,
          name: presetName.trim(),
          model: selectedModel,
          systemPrompt: systemPrompt,
          temperature: temperature,
          maxTokens: maxTokens,
          tools: selectedTools,
          createdAt: new Date().toISOString(),
          hasConversation: false, // Inicialmente n√£o tem conversa salva
          attachedFiles: presetAttachedFiles // Arquivos anexados durante a cria√ß√£o
        };
        
        // Adicionar √† lista de presets
        updatedPresets = [...presets, newPreset];
      }
      
      // Atualizar estado e localStorage
      setPresets(updatedPresets);
      localStorage.setItem('chat_presets', JSON.stringify(updatedPresets));
      
      // Fechar di√°logo e notificar
      setPresetSaveOpen(false);
      setPresetToEdit(null); // Limpar estado de edi√ß√£o
      
      setSnackbar({
        open: true,
        message: isEditing 
          ? `Preset "${presetName}" atualizado com sucesso` 
          : `Preset "${presetName}" salvo com sucesso`
      });
      
      // Navegar para o preset
      navigate(`/prompt-chat/${presetId}`);
    } catch (e) {
      console.error('Error saving preset:', e);
      setSnackbar({
        open: true,
        message: 'Erro ao salvar preset: ' + e.message
      });
    }
  };
  
  // Salvar conversa atual com o worker
  const handleSaveConversationWithPreset = () => {
    // Extrair o ID base do worker do chatId
    const workerBaseId = id.includes('_chat_') ? id.split('_chat_')[0] : id;
    
    if (!workerBaseId || workerBaseId === 'default') {
      setSnackbar({
        open: true,
        message: 'Salve primeiro como worker para poder salvar a conversa'
      });
      return;
    }
    
    try {
      // Encontrar o worker (preset) atual
      const presetIndex = presets.findIndex(p => p.id === workerBaseId);
      if (presetIndex === -1) {
        throw new Error('Worker n√£o encontrado');
      }
      
      // Salvar a conversa atual no localStorage com o ID atual
      conversationRef.current.save(id);
      
      // Marcar o worker como tendo uma conversa salva
      const updatedPresets = [...presets];
      updatedPresets[presetIndex] = {
        ...updatedPresets[presetIndex],
        hasConversation: true,
        lastUpdated: new Date().toISOString()
      };
      
      // Atualizar estado e localStorage
      setPresets(updatedPresets);
      localStorage.setItem('chat_presets', JSON.stringify(updatedPresets));
      
      // Atualizar o preset atual
      setCurrentPreset(updatedPresets[presetIndex]);
      
      setSnackbar({
        open: true,
        message: 'Conversa salva com sucesso!'
      });
    } catch (e) {
      console.error('Error saving conversation with preset:', e);
      setSnackbar({
        open: true,
        message: 'Erro ao salvar conversa: ' + e.message
      });
    }
  };
  
  // Abrir o gerenciador de presets
  const handleOpenPresetManager = () => {
    setPresetManagerOpen(true);
  };
  
  // Abrir menu de op√ß√µes do preset
  const handlePresetMenuClick = (event, preset) => {
    setPresetAnchorEl(event.currentTarget);
    setPresetToEdit(preset);
  };
  
  // Fechar menu de op√ß√µes do preset
  const handlePresetMenuClose = () => {
    setPresetAnchorEl(null);
    setPresetToEdit(null);
  };
  
  // Editar um preset existente
  const handleEditPreset = () => {
    if (!presetToEdit) return;
    
    // Fechar o menu
    handlePresetMenuClose();
    
    // Abrir o di√°logo de edi√ß√£o com os valores preenchidos
    setPresetName(presetToEdit.name);
    setSelectedModel(presetToEdit.model || 'claude-3-7-sonnet-20250219');
    setSystemPrompt(presetToEdit.systemPrompt || '');
    setTemperature(presetToEdit.temperature || 0.7);
    setMaxTokens(presetToEdit.maxTokens || 2048);
    setSelectedTools(presetToEdit.tools || []);
    setPresetAttachedFiles(presetToEdit.attachedFiles || []);
    
    // Abrir o di√°logo de configura√ß√µes para edi√ß√£o
    setSettingsOpen(true);
  };
  
  // Confirmar exclus√£o de um preset
  const handleConfirmDeletePreset = () => {
    if (!presetToEdit) return;
    
    // Fechar o menu e abrir di√°logo de confirma√ß√£o
    handlePresetMenuClose();
    setPresetToDelete(presetToEdit);
    setConfirmDeleteOpen(true);
  };
  
  // Excluir um preset
  const handleDeletePreset = () => {
    if (!presetToDelete) return;
    
    try {
      // Filtrar o preset da lista
      const updatedPresets = presets.filter(p => p.id !== presetToDelete.id);
      
      // Atualizar estado e localStorage
      setPresets(updatedPresets);
      localStorage.setItem('chat_presets', JSON.stringify(updatedPresets));
      
      // Remover dados da conversa associados ao preset
      localStorage.removeItem(`conversation_${presetToDelete.id}`);
      
      // Voltar ao chat padr√£o se o preset exclu√≠do era o atual
      if (id === presetToDelete.id) {
        navigate('/prompt-chat');
      }
      
      setSnackbar({
        open: true,
        message: `Preset "${presetToDelete.name}" exclu√≠do com sucesso`
      });
    } catch (e) {
      console.error('Error deleting preset:', e);
      setSnackbar({
        open: true,
        message: 'Erro ao excluir preset: ' + e.message
      });
    } finally {
      // Fechar di√°logo de confirma√ß√£o
      setConfirmDeleteOpen(false);
      setPresetToDelete(null);
    }
  };
  
  // Fechar snackbar
  const handleCloseSnackbar = () => {
    setSnackbar({ ...snackbar, open: false });
  };
  
  // Abrir di√°logo de confirma√ß√£o para reiniciar conversa
  const handleOpenResetConfirm = () => {
    if (isTyping || activeRunId) {
      setSnackbar({
        open: true,
        message: 'Aguarde o t√©rmino da resposta atual antes de reiniciar a conversa.'
      });
      return;
    }
    setConfirmResetOpen(true);
  };
  
  // Fechar di√°logo de confirma√ß√£o
  const handleCloseResetConfirm = () => {
    setConfirmResetOpen(false);
  };
  
  // Reiniciar conversa
  const handleResetConversation = () => {
    if (isTyping || activeRunId) {
      setSnackbar({
        open: true,
        message: 'Aguarde o t√©rmino da resposta atual antes de reiniciar a conversa.'
      });
      return;
    }
    
    setIsResettingThread(true);
    setError(null);
    
    try {
      // Resetar o gerenciador de conversa
      conversationRef.current.reset(systemPrompt);
      
      // Limpar mensagens da UI
      setMessages([]);
      
      // Limpar localStorage para essa conversa
      const currentChatId = window.location.pathname.split('/').pop();
      localStorage.removeItem(`conversation_${currentChatId}`);
      
      setSnackbar({
        open: true,
        message: 'Conversa reiniciada com sucesso!'
      });
    } catch (err) {
      console.error('Error resetting conversation:', err);
      setError('Erro ao reiniciar conversa: ' + (err.message || 'Erro desconhecido'));
    } finally {
      setIsResettingThread(false);
      handleCloseResetConfirm();
    }
  };
  
  return (
    <Box sx={{ 
      height: '100%', 
      display: 'flex', 
      flexDirection: 'column',
      position: 'relative',
      bgcolor: 'background.default',
      borderRadius: 1,
      overflow: 'hidden'
    }}>
      {/* Banner de instru√ß√µes removido */}
      
      {/* Cabe√ßalho simplificado */}
      <AppBar position="static" color="default" elevation={1}>
        <Box sx={{ display: 'flex', alignItems: 'center', padding: 2 }}>
          <IconButton 
            edge="start" 
            color="inherit" 
            onClick={() => navigate('/')}
            sx={{ mr: 1 }}
          >
            <ArrowBackIcon />
          </IconButton>
          
          <Avatar sx={{ bgcolor: 'primary.main', mr: 2 }}>
            <SmartToyIcon />
          </Avatar>
          
          <Box sx={{ flexGrow: 1 }}>
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <Typography variant="h6">
                {currentPreset ? currentPreset.name : 'Chat com IA'}
              </Typography>
              
              {currentPreset && (
                <Tooltip title="Worker configurado">
                  <Chip 
                    icon={<TuneIcon fontSize="small" />}
                    label="Worker" 
                    size="small"
                    color="primary"
                    variant="outlined"
                    sx={{ ml: 1, height: 20, fontSize: '0.6rem' }}
                  />
                </Tooltip>
              )}
            </Box>
            
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <Chip 
                label={AVAILABLE_MODELS.find(m => m.id === selectedModel)?.name || selectedModel}
                size="small"
                color="primary"
                sx={{ 
                  fontSize: '0.75rem',
                  fontWeight: 'bold',
                  background: selectedModel.includes('1106') ? '#FF6B6B' : 
                              selectedModel.includes('2024-04-09') ? '#4ECDC4' : 
                              selectedModel.includes('turbo') ? '#9D65C9' : '#30475E'
                }}
              />
              
              {currentPreset?.hasConversation && (
                <Tooltip title="Este preset tem uma conversa salva">
                  <Chip 
                    label="Conversa salva" 
                    size="small"
                    variant="outlined"
                    sx={{ ml: 1, height: 20, fontSize: '0.65rem' }}
                  />
                </Tooltip>
              )}
            </Box>
          </Box>
          
          {currentPreset && (
            <>
              <Tooltip title="Salvar conversa atual com este worker">
                <IconButton 
                  color="primary" 
                  onClick={handleSaveConversationWithPreset}
                  disabled={isTyping || activeRunId}
                >
                  <SaveIcon />
                </IconButton>
              </Tooltip>
              <Tooltip title="Iniciar nova conversa com este worker">
                <IconButton 
                  color="secondary" 
                  onClick={() => navigate(`/prompt-chat/${currentPreset.id}?new=true&forcenew=true&t=${Date.now()}`)}
                  disabled={isTyping || activeRunId}
                >
                  <AddIcon />
                </IconButton>
              </Tooltip>
            </>
          )}
          
          {/* Bot√£o de configura√ß√µes removido - editar workers apenas na tela inicial */}
        </Box>
      </AppBar>
      
      {/* √Årea de mensagens */}
      <Box 
        sx={{ 
          flex: 1, 
          overflow: 'auto', 
          py: 2, 
          px: { xs: 2, sm: 3 }, 
          display: 'flex',
          flexDirection: 'column'
        }}
        onScroll={handleScroll}
      >
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}
        
        {messages.length === 0 && (
          <Box sx={{ 
            display: 'flex', 
            flexDirection: 'column', 
            alignItems: 'center', 
            justifyContent: 'center',
            height: '100%',
            opacity: 0.8
          }}>
            <SmartToyIcon sx={{ fontSize: 60, color: 'primary.main', mb: 2 }} />
            <Typography variant="h5" gutterBottom>
              Chat com Modelo de IA
            </Typography>
            <Typography variant="body2" color="text.secondary" align="center" sx={{ maxWidth: 500 }}>
              Comece uma conversa enviando uma mensagem. Voc√™ pode fazer perguntas, 
              pedir sugest√µes, ou solicitar ajuda com tarefas.
            </Typography>
          </Box>
        )}
        
        <List sx={{ width: '100%', maxWidth: 800, mx: 'auto' }}>
          {messages.map((message, index) => (
            <React.Fragment key={index}>
              <ListItem alignItems="flex-start" sx={{ 
                bgcolor: message.role === 'assistant' ? 'background.paper' : 'transparent',
                borderRadius: 2,
                mb: 2,
                p: 2
              }}>
                <ListItemAvatar>
                  <Avatar sx={{ 
                    bgcolor: message.role === 'assistant' ? 'primary.main' : 'secondary.main'
                  }}>
                    {message.role === 'assistant' ? <SmartToyIcon /> : <PersonIcon />}
                  </Avatar>
                </ListItemAvatar>
                <ListItemText
                  primary={message.role === 'assistant' ? 'Assistente' : 'Voc√™'}
                  secondaryTypographyProps={{ component: 'div' }}
                  secondary={
                    <Box>
                      <Box 
                        sx={{ 
                          mt: 1,
                          color: message.isError ? "error.main" : "text.primary",
                          '& .markdown': {
                            '& h1': { fontSize: '1.5rem', fontWeight: 'bold', my: 1 },
                            '& h2': { fontSize: '1.3rem', fontWeight: 'bold', my: 1 },
                            '& h3': { fontSize: '1.15rem', fontWeight: 'bold', my: 1 },
                            '& h4': { fontSize: '1.1rem', fontWeight: 'bold', my: 0.8 },
                            '& h5': { fontSize: '1.05rem', fontWeight: 'bold', my: 0.8 },
                            '& h6': { fontSize: '1rem', fontWeight: 'bold', my: 0.8 },
                            '& p': { my: 0.8 },
                            '& a': { color: 'primary.main', textDecoration: 'none' },
                            '& img': { maxWidth: '100%', my: 1 },
                            '& blockquote': { 
                              pl: 2, 
                              borderLeft: '4px solid', 
                              borderColor: 'divider',
                              my: 1,
                              ml: 0,
                              fontStyle: 'italic',
                              bgcolor: 'rgba(0,0,0,0.03)',
                              py: 0.5
                            },
                            '& pre': { 
                              backgroundColor: 'rgba(0,0,0,0.04)', 
                              p: 1, 
                              borderRadius: 1,
                              overflowX: 'auto',
                              '& code': {
                                fontFamily: 'monospace'
                              }
                            },
                            '& code': { 
                              fontFamily: 'monospace',
                              backgroundColor: 'rgba(0,0,0,0.04)',
                              px: 0.5,
                              borderRadius: 0.5
                            },
                            '& ul, & ol': { pl: 3, my: 1 },
                            '& table': {
                              borderCollapse: 'collapse',
                              width: '100%',
                              my: 1,
                              '& th, & td': {
                                border: '1px solid',
                                borderColor: 'divider',
                                p: 1
                              },
                              '& th': {
                                backgroundColor: 'rgba(0,0,0,0.04)'
                              }
                            },
                            '& hr': {
                              border: 'none',
                              height: '1px',
                              backgroundColor: 'divider',
                              my: 2
                            }
                          }
                        }}
                      >
                        {message.isThinking || message.isError ? (
                          <Typography variant="body1">
                            {message.content}
                          </Typography>
                        ) : (
                          <ReactMarkdown 
                            className="markdown"
                            remarkPlugins={[remarkGfm]}
                          >
                            {message.content}
                          </ReactMarkdown>
                        )}
                      </Box>
                      
                      {message.attachedFile && (
                        <Box 
                          sx={{ 
                            display: 'flex', 
                            alignItems: 'center', 
                            mt: 1,
                            p: 1,
                            bgcolor: 'rgba(0, 0, 0, 0.04)',
                            borderRadius: 1,
                            maxWidth: 'fit-content'
                          }}
                        >
                          {message.attachedFile.extension === 'pdf' ? (
                            <PictureAsPdfIcon fontSize="small" sx={{ mr: 1, color: '#e53935' }} />
                          ) : message.attachedFile.extension === 'csv' ? (
                            <TableChartIcon fontSize="small" sx={{ mr: 1, color: '#43a047' }} />
                          ) : (
                            <DescriptionIcon fontSize="small" sx={{ mr: 1, color: '#1e88e5' }} />
                          )}
                          <Typography variant="caption" sx={{ fontWeight: 500 }}>
                            {message.attachedFile.name}
                          </Typography>
                        </Box>
                      )}
                      
                      {message.isStreaming && (
                        <Box sx={{ display: 'flex', alignItems: 'center', mt: 1 }}>
                          {message.isThinking ? (
                            <>
                              <CircularProgress size={12} sx={{ mr: 1 }} />
                              <Typography variant="caption" color="text.secondary" component="span">
                                Pensando...
                              </Typography>
                            </>
                          ) : (
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                              <Box 
                                sx={{ 
                                  width: '8px', 
                                  height: '8px', 
                                  borderRadius: '50%', 
                                  backgroundColor: 'primary.main',
                                  mr: 0.5,
                                  animation: 'pulse 1.5s infinite',
                                  '@keyframes pulse': {
                                    '0%': { opacity: 0.4 },
                                    '50%': { opacity: 1 },
                                    '100%': { opacity: 0.4 },
                                  },
                                }} 
                              />
                              <Typography variant="caption" color="text.secondary" component="span">
                                Digitando em tempo real...
                              </Typography>
                            </Box>
                          )}
                        </Box>
                      )}
                    </Box>
                  }
                />
              </ListItem>
              {index < messages.length - 1 && <Divider variant="inset" component="li" />}
            </React.Fragment>
          ))}
          <div ref={messagesEndRef} />
        </List>
      </Box>
      
      {/* √Årea de input */}
      <Paper 
        component="form" 
        onSubmit={handleSendMessage} 
        sx={{ 
          p: 2, 
          mx: { xs: 2, sm: 3 }, 
          mb: 2, 
          display: 'flex', 
          flexDirection: 'column',
          maxWidth: 800,
          width: 'auto',
          alignSelf: 'center',
          boxShadow: 3,
          borderRadius: 2,
          width: '100%',
          position: 'relative'
        }}
      >
        {activeRunId && (
          <Box
            sx={{
              position: 'absolute',
              top: -30,
              left: '50%',
              transform: 'translateX(-50%)',
              backgroundColor: 'primary.main',
              color: 'white',
              py: 0.5,
              px: 2,
              borderRadius: '12px 12px 0 0',
              fontSize: '0.75rem',
              display: 'flex',
              alignItems: 'center',
              gap: 1,
              boxShadow: 1
            }}
          >
            <CircularProgress size={12} sx={{ color: 'white' }} />
            <span>Processando resposta...</span>
          </Box>
        )}
        
        {attachedFile && (
          <Box 
            sx={{ 
              display: 'flex', 
              alignItems: 'center', 
              mb: 2,
              pb: 1.5,
              borderBottom: '1px solid rgba(0,0,0,0.08)'
            }}
          >
            <Box 
              sx={{ 
                display: 'flex', 
                alignItems: 'center', 
                bgcolor: 'rgba(25, 118, 210, 0.08)',
                borderRadius: 1,
                p: 0.75,
                pl: 1,
                pr: 1
              }}
            >
              {attachedFile.extension === 'pdf' ? (
                <PictureAsPdfIcon fontSize="small" sx={{ mr: 1, color: '#e53935' }} />
              ) : attachedFile.extension === 'csv' ? (
                <TableChartIcon fontSize="small" sx={{ mr: 1, color: '#43a047' }} />
              ) : (
                <DescriptionIcon fontSize="small" sx={{ mr: 1, color: '#1e88e5' }} />
              )}
              <Typography variant="body2" noWrap sx={{ mr: 1, maxWidth: 200 }}>
                {attachedFile.name}
              </Typography>
              <IconButton 
                size="small" 
                onClick={handleRemoveFile}
                sx={{ 
                  p: 0.5, 
                  '&:hover': { 
                    bgcolor: 'rgba(0,0,0,0.1)' 
                  } 
                }}
              >
                <Typography variant="caption" sx={{ fontWeight: 'bold' }}>√ó</Typography>
              </IconButton>
            </Box>
            <Typography variant="caption" color="text.secondary" sx={{ ml: 1.5 }}>
              Este arquivo ser√° enviado com a mensagem
            </Typography>
          </Box>
        )}
        
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <TextField
            fullWidth
            placeholder={activeRunId 
              ? "Aguarde o t√©rmino da resposta atual..." 
              : "Envie uma mensagem... (suporta Markdown)"
            }
            variant="standard"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (input.trim() && !isTyping && !activeRunId && hasApiKey()) {
                  handleSendMessage(e);
                }
              }
            }}
            multiline
            maxRows={4}
            sx={{ flexGrow: 1, mr: 1 }}
            InputProps={{ 
              disableUnderline: true,
              sx: activeRunId ? { opacity: 0.6 } : {}
            }}
            disabled={isTyping || activeRunId || !hasApiKey()}
          />
          
          <Tooltip title="Anexar arquivo (PDF, CSV, TXT, Markdown)">
            <span>
              <IconButton
                color="default"
                onClick={handleOpenFileSelector}
                disabled={isTyping || activeRunId || !hasApiKey() || uploadingFile || !!attachedFile}
                sx={{ mr: 0.5, opacity: activeRunId ? 0.5 : 1 }}
              >
                <AttachFileIcon />
              </IconButton>
            </span>
          </Tooltip>
          
          <Tooltip title={activeRunId 
            ? "Aguarde o t√©rmino da resposta atual" 
            : (!input.trim() && attachedFile ? "Enviar arquivo anexado" : "Enviar mensagem")
          }>
            <span>
              <IconButton 
                color="primary" 
                aria-label="enviar mensagem" 
                onClick={handleSendMessage}
                disabled={(!input.trim() && !attachedFile) || isTyping || activeRunId || !hasApiKey()}
                sx={{ 
                  bgcolor: (!input.trim() && attachedFile) ? 'rgba(25, 118, 210, 0.08)' : 'transparent',
                  opacity: activeRunId ? 0.5 : 1
                }}
              >
                <SendIcon />
              </IconButton>
            </span>
          </Tooltip>
        </Box>
        
        {/* Input de arquivo invis√≠vel */}
        <input
          ref={fileInputRef}
          type="file"
          accept=".pdf,.csv,.txt,.md,.markdown,application/pdf,text/csv,text/plain,text/markdown"
          style={{ display: 'none' }}
          onChange={handleFileSelected}
          multiple={false}
        />
      </Paper>
      
      {/* Snackbar para notifica√ß√µes */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        message={snackbar.message}
      />
      
      {/* Di√°logo de configura√ß√µes removido - apenas poss√≠vel editar workers na tela inicial */}
      
      {/* Di√°logo para salvar worker */}
      <Dialog
        open={savePresetOpen}
        onClose={() => {
          setPresetSaveOpen(false);
          setPresetToEdit(null);
        }}
        aria-labelledby="save-preset-dialog-title"
      >
        <DialogTitle id="save-preset-dialog-title">
          {presetToEdit ? `Editar Worker "${presetToEdit.name}"` : 'Salvar como Worker'}
        </DialogTitle>
        <DialogContent>
          <DialogContentText sx={{ mb: 2 }}>
            {presetToEdit 
              ? 'Atualize as configura√ß√µes deste worker. As conversas salvas n√£o ser√£o afetadas.'
              : 'Salve estas configura√ß√µes como um worker para reuso futuro. Voc√™ poder√° iniciar novas conversas com este worker a partir da lista de workers salvos.'}
          </DialogContentText>
          <TextField
            autoFocus
            label="Nome do Worker"
            fullWidth
            value={presetName}
            onChange={(e) => setPresetName(e.target.value)}
            sx={{ mt: 1 }}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => {
            setPresetSaveOpen(false);
            setPresetToEdit(null);
          }}>
            Cancelar
          </Button>
          <Button 
            onClick={handleSavePreset} 
            variant="contained" 
            color="primary"
            startIcon={presetToEdit ? <EditIcon /> : <SaveIcon />}
          >
            {presetToEdit ? 'Atualizar' : 'Salvar'}
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Di√°logo de confirma√ß√£o para reiniciar conversa */}
      <Dialog
        open={confirmResetOpen}
        onClose={handleCloseResetConfirm}
        aria-labelledby="reset-dialog-title"
      >
        <DialogTitle id="reset-dialog-title" sx={{ display: 'flex', alignItems: 'center' }}>
          <WarningIcon color="warning" sx={{ mr: 1 }} />
          Reiniciar conversa?
        </DialogTitle>
        <DialogContent>
          <DialogContentText>
            Isso ir√° apagar todas as mensagens e iniciar uma nova conversa.
            Esta a√ß√£o n√£o pode ser desfeita.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseResetConfirm} color="primary">
            Cancelar
          </Button>
          <Button 
            onClick={handleResetConversation} 
            color="primary" 
            variant="contained"
            startIcon={isResettingThread ? <CircularProgress size={16} color="inherit" /> : null}
            disabled={isResettingThread}
          >
            {isResettingThread ? 'Reiniciando...' : 'Reiniciar conversa'}
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Di√°logo do Gerenciador de Presets */}
      <Dialog
        open={presetManagerOpen}
        onClose={() => setPresetManagerOpen(false)}
        aria-labelledby="preset-manager-dialog-title"
        maxWidth="md"
        fullWidth
      >
        <DialogTitle id="preset-manager-dialog-title">
          Gerenciador de Configura√ß√µes
        </DialogTitle>
        <DialogContent>
          <Box sx={{ mb: 2 }}>
            <Typography variant="body2" color="text.secondary" paragraph>
              Crie e gerencie configura√ß√µes personalizadas para diferentes tipos de conversa.
              As configura√ß√µes salvas ficar√£o dispon√≠veis no menu lateral para r√°pido acesso.
            </Typography>
          </Box>
          
          {presets.length === 0 ? (
            <Box sx={{ 
              display: 'flex', 
              flexDirection: 'column', 
              alignItems: 'center',
              justifyContent: 'center',
              py: 4,
              bgcolor: 'background.paper',
              borderRadius: 1
            }}>
              <TuneIcon sx={{ fontSize: 48, color: 'text.secondary', mb: 2, opacity: 0.5 }} />
              <Typography variant="h6" sx={{ mb: 1 }}>Nenhum preset salvo</Typography>
              <Typography variant="body2" color="text.secondary" align="center" sx={{ maxWidth: 400, mb: 2 }}>
                Crie um novo preset salvando suas configura√ß√µes atuais clicando no bot√£o "Configura√ß√µes".
              </Typography>
              <Button
                variant="outlined"
                startIcon={<SettingsIcon />}
                onClick={() => {
                  setPresetManagerOpen(false);
                  setSettingsOpen(true);
                }}
              >
                Configurar e salvar
              </Button>
            </Box>
          ) : (
            <Box sx={{ 
              display: 'grid', 
              gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))',
              gap: 2
            }}>
              {presets.map(preset => (
                <Card 
                  key={preset.id} 
                  variant="outlined"
                  sx={{
                    border: preset.id === id 
                      ? '2px solid' 
                      : '1px solid',
                    borderColor: preset.id === id 
                      ? 'primary.main' 
                      : 'divider',
                    position: 'relative'
                  }}
                >
                  {preset.id === id && (
                    <Box 
                      sx={{ 
                        position: 'absolute', 
                        top: 0, 
                        right: 0, 
                        bgcolor: 'primary.main',
                        color: 'white',
                        px: 1,
                        py: 0.2,
                        fontSize: '0.65rem',
                        borderBottomLeftRadius: 4
                      }}
                    >
                      Ativo
                    </Box>
                  )}
                  <CardContent>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                      <Typography 
                        variant="h6" 
                        component="div" 
                        sx={{ 
                          fontWeight: 500,
                          color: preset.id === id ? 'primary.main' : 'text.primary'
                        }}
                      >
                        {preset.name}
                      </Typography>
                      
                      <IconButton
                        size="small"
                        onClick={(e) => handlePresetMenuClick(e, preset)}
                      >
                        <MoreVertIcon fontSize="small" />
                      </IconButton>
                    </Box>
                    
                    <Divider sx={{ mb: 1 }} />
                    
                    <Typography variant="body2" color="text.secondary" gutterBottom>
                      {AVAILABLE_MODELS.find(m => m.id === preset.model)?.name || preset.model}
                    </Typography>
                    
                    <Typography variant="caption" color="text.secondary" 
                      sx={{ 
                        display: 'block', 
                        mb: 1,
                        whiteSpace: 'nowrap',
                        overflow: 'hidden',
                        textOverflow: 'ellipsis',
                        maxWidth: '100%'
                      }}
                    >
                      System Prompt: {preset.systemPrompt?.substring(0, 50) || 'Nenhum prompt configurado'}{preset.systemPrompt?.length > 50 ? '...' : ''}
                    </Typography>
                    
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mt: 1 }}>
                      {preset.tools && preset.tools.length > 0 ? preset.tools.map(toolId => {
                        const tool = AVAILABLE_TOOLS.find(t => t.id === toolId);
                        return tool ? (
                          <Chip
                            key={toolId}
                            label={tool.name}
                            size="small"
                            sx={{ fontSize: '0.65rem', height: 20 }}
                          />
                        ) : null;
                      }) : (
                        <Typography variant="caption" color="text.secondary">
                          Sem ferramentas adicionais
                        </Typography>
                      )}
                    </Box>
                  </CardContent>
                  <CardActions>
                    {preset.id === id ? (
                      <Button 
                        size="small"
                        variant="contained"
                        color="primary"
                        disabled
                      >
                        Ativo
                      </Button>
                    ) : (
                      <Button 
                        size="small" 
                        variant="outlined"
                        onClick={() => {
                          navigate(`/prompt-chat/${preset.id}`);
                          setPresetManagerOpen(false);
                        }}
                      >
                        Usar
                      </Button>
                    )}
                    {preset.hasConversation && (
                      <Chip 
                        label="Conversa salva" 
                        size="small"
                        variant="outlined"
                        sx={{ ml: 'auto', height: 20, fontSize: '0.65rem' }}
                      />
                    )}
                  </CardActions>
                </Card>
              ))}
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={() => {
              setPresetManagerOpen(false);
              setSettingsOpen(true);
            }} 
            startIcon={<SaveIcon />}
          >
            Salvar atual como preset
          </Button>
          <Button onClick={() => setPresetManagerOpen(false)}>
            Fechar
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Menu de op√ß√µes do preset */}
      <Menu
        anchorEl={presetAnchorEl}
        open={Boolean(presetAnchorEl)}
        onClose={handlePresetMenuClose}
      >
        <MenuItem onClick={handleEditPreset}>
          <ListItemIcon>
            <EditIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText>Editar</ListItemText>
        </MenuItem>
        <MenuItem onClick={handleConfirmDeletePreset}>
          <ListItemIcon>
            <DeleteIcon fontSize="small" color="error" />
          </ListItemIcon>
          <ListItemText>Excluir</ListItemText>
        </MenuItem>
      </Menu>
      
      {/* Di√°logo de confirma√ß√£o de exclus√£o de preset */}
      <Dialog
        open={confirmDeleteOpen}
        onClose={() => setConfirmDeleteOpen(false)}
        aria-labelledby="delete-preset-dialog-title"
      >
        <DialogTitle id="delete-preset-dialog-title" sx={{ display: 'flex', alignItems: 'center' }}>
          <WarningIcon color="error" sx={{ mr: 1 }} />
          Excluir preset?
        </DialogTitle>
        <DialogContent>
          <DialogContentText>
            Voc√™ est√° prestes a excluir o preset "{presetToDelete?.name}".
            {presetToDelete?.hasConversation && ' A conversa salva com este preset tamb√©m ser√° exclu√≠da.'}
            Esta a√ß√£o n√£o pode ser desfeita.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setConfirmDeleteOpen(false)} color="primary">
            Cancelar
          </Button>
          <Button 
            onClick={handleDeletePreset} 
            color="error" 
            variant="contained"
          >
            Excluir
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

// Clean export statement
export default PromptChat;